# LLMRPG 项目快速上手指南

## 一、项目入口与启动

### 1.1 后端入口

**主入口文件：**
- `config/routes.rb` - 路由定义，所有URL入口
- `app/controllers/application_controller.rb` - 所有控制器的基类
- `app/controllers/home_controller.rb` - 首页控制器（root路径）

**启动方式：**
```bash
bin/dev  # 同时启动Rails服务器、JS构建、CSS构建
```

**关键配置文件：**
- `config/application.rb` - Rails应用配置
- `config/database.yml` - 数据库配置
- `Gemfile` - Ruby依赖

### 1.2 前端入口

**主入口文件：**
- `app/javascript/application.js` - JavaScript主入口，加载Turbo和Stimulus
- `app/assets/stylesheets/application.tailwind.css` - CSS主入口，Tailwind配置
- `app/views/layouts/application.html.erb` - HTML布局模板

**构建流程：**
- JS: `app/javascript/*.js` → esbuild → `app/assets/builds/application.js`
- CSS: `app/assets/stylesheets/application.tailwind.css` → Tailwind CLI → `app/assets/builds/application.css`

## 二、核心业务逻辑追踪路径

### 2.1 用户发送消息的完整流程（核心业务）

**追踪路径：**

1. **前端表单提交** → `app/views/messages/_form.html.erb`
   - 使用 `form_with` 提交到 `conversation_messages_path`

2. **路由匹配** → `config/routes.rb:22`
   ```ruby
   resources :conversations do
     resources :messages, only: [ :create ]
   end
   ```

3. **控制器处理** → `app/controllers/messages_controller.rb:create`
   - 创建用户消息
   - 触发后台任务：`CompleteConversationJob.perform_later`
   - 返回 Turbo Stream 更新表单

4. **后台任务** → `app/jobs/complete_conversation_job.rb:perform`
   - 构建对话上下文（房间提示词 + 角色提示词 + 历史消息）
   - 调用 OpenAI API 流式生成回复
   - 实时广播消息片段到前端

5. **模型自动广播** → `app/models/message.rb:15`
   - `broadcasts_to :conversation` - 消息保存时自动广播

6. **前端接收更新** → `app/views/rooms/show.html.erb:114`
   - `<%= turbo_stream_from @conversation %>` - 订阅对话的实时更新

### 2.2 核心业务文件清单

**模型层（数据逻辑）：**
- `app/models/user.rb` - 用户
- `app/models/character.rb` - 角色
- `app/models/room.rb` - 房间
- `app/models/conversation.rb` - 对话
- `app/models/message.rb` - 消息（核心：`broadcasts_to`）

**控制器层（业务逻辑）：**
- `app/controllers/rooms_controller.rb` - 房间管理
- `app/controllers/messages_controller.rb` - 消息创建（核心）
- `app/controllers/conversations_controller.rb` - 对话管理

**任务层（异步处理）：**
- `app/jobs/complete_conversation_job.rb` - AI对话生成（核心）

**视图层（展示逻辑）：**
- `app/views/rooms/show.html.erb` - 聊天界面主页面
- `app/views/messages/_message.html.erb` - 单条消息组件
- `app/views/messages/_form.html.erb` - 消息输入表单

## 三、WebSocket/实时通信实现

### 3.1 技术栈

项目使用 **Turbo Streams**（基于 Action Cable/WebSocket）实现实时通信，不是传统的 WebSocket 直接实现。

### 3.2 实现机制

**1. 连接配置** → `config/cable.yml`
- 开发环境：`adapter: async`（内存适配器）
- 生产环境：`adapter: redis`（Redis适配器）

**2. 连接认证** → `app/channels/application_cable/connection.rb`
- 通过 session cookie 识别用户
- 每个连接绑定 `current_user`

**3. 订阅机制** → `app/views/rooms/show.html.erb:114`
```erb
<%= turbo_stream_from @conversation %>
```
- 前端自动订阅 `conversation` 的广播流
- 当该 conversation 有更新时，前端自动接收

**4. 广播触发方式（两种）：**

**方式A：模型自动广播** → `app/models/message.rb:15`
```ruby
broadcasts_to :conversation
```
- 消息保存时自动广播到订阅的客户端
- 使用标准的 Turbo Stream Actions（append, replace等）

**方式B：编程式广播** → `app/jobs/complete_conversation_job.rb:62-69`
```ruby
Turbo::StreamsChannel.broadcast_stream_to(
  conversation,
  content: <<~HTML
    <turbo-stream action="message_chunk" target="message_#{character_message.id}">
      <template>#{content_chunk}</template>
    </turbo-stream>
  HTML
)
```
- 在后台任务中手动广播
- 使用自定义的 `message_chunk` Action 实现流式传输

**5. 自定义 Stream Action** → `app/javascript/application.js:8-12`
```javascript
Turbo.StreamActions.message_chunk = function () {
  this.targetElements.forEach((element) => {
    element.dataset.messageContentValue = (element.dataset.messageContentValue || "") + this.templateContent.textContent
  })
}
```
- 自定义 Action 用于流式追加消息内容
- 每次收到片段，追加到目标元素的 `data-message-content-value` 属性

**6. Stimulus 响应更新** → `app/javascript/controllers/message_controller.js:32-34`
```javascript
contentValueChanged() {
  this.renderContent()  // 当 contentValue 变化时，重新渲染 Markdown
}
```
- Stimulus 监听 `data-message-content-value` 的变化
- 自动触发 Markdown 渲染

### 3.3 实时通信流程图

```
用户发送消息
  ↓
MessagesController#create
  ↓
保存消息 → Message.broadcasts_to (自动广播)
  ↓
触发 CompleteConversationJob
  ↓
OpenAI 流式生成 → 每收到片段
  ↓
Turbo::StreamsChannel.broadcast_stream_to (手动广播)
  ↓
前端 turbo_stream_from 接收
  ↓
自定义 message_chunk Action 处理
  ↓
更新 DOM → Stimulus 响应 → 渲染 Markdown
```

## 四、Tailwind CSS 使用指南

### 4.1 入口文件

**主入口：** `app/assets/stylesheets/application.tailwind.css`
```css
@import "tailwindcss" source(none);
@plugin "daisyui";  // DaisyUI 组件库
@plugin "@tailwindcss/typography";  // 排版插件
```

### 4.2 在视图中使用

**直接在 HTML 类名中使用：**
```erb
<!-- app/views/rooms/show.html.erb -->
<div class="flex flex-col h-screen">  <!-- 弹性布局，全屏高度 -->
  <div class="navbar shadow-xs bg-base-100">  <!-- DaisyUI 导航栏 -->
    <button class="btn btn-ghost btn-square">  <!-- DaisyUI 按钮 -->
```

**常用模式：**
- 布局：`flex`, `grid`, `container`, `mx-auto`（居中）
- 间距：`p-4`（内边距）, `mt-2`（外边距）, `gap-4`（网格间距）
- 颜色：`bg-base-100`（DaisyUI主题色）, `text-gray-600`
- 响应式：`md:grid-cols-2`（中等屏幕2列）

### 4.3 构建流程

**开发环境：**
```bash
npm run build:css -- --watch  # 监听文件变化，自动编译
```

**构建命令：** `package.json:9`
```json
"build:css": "npx @tailwindcss/cli -i ./app/assets/stylesheets/application.tailwind.css -o ./app/assets/builds/application.css --minify"
```

### 4.4 学习建议

1. **先看现有代码**：查看 `app/views/rooms/show.html.erb` 中的类名使用
2. **参考文档**：Tailwind CSS 官方文档 + DaisyUI 组件文档
3. **实践**：修改现有页面的样式，观察效果

## 五、前后端交互逻辑

### 5.1 传统请求-响应（无刷新）

**示例：创建消息** → `app/controllers/messages_controller.rb:12`
```ruby
render turbo_stream: turbo_stream.replace(helpers.dom_id(message, :form), partial: "messages/form", locals: { message: message })
```

**流程：**
1. 表单提交（Turbo 拦截，不刷新页面）
2. 后端返回 Turbo Stream HTML
3. Turbo 解析并更新 DOM

### 5.2 实时推送（WebSocket）

**示例：AI 回复流式传输**

**后端推送：** `app/jobs/complete_conversation_job.rb:62`
```ruby
Turbo::StreamsChannel.broadcast_stream_to(conversation, content: ...)
```

**前端订阅：** `app/views/rooms/show.html.erb:114`
```erb
<%= turbo_stream_from @conversation %>
```

**流程：**
1. 前端页面加载时自动订阅
2. 后端通过 WebSocket 推送更新
3. Turbo 自动更新 DOM

### 5.3 Stimulus 交互逻辑

**示例：消息 Markdown 渲染** → `app/javascript/controllers/message_controller.js`

**连接：** HTML 中的 `data-controller="message"`
```erb
<div data-controller="message" 
     data-message-status-value="<%= message.status %>"
     data-message-content-value="<%= message.content %>">
```

**响应：** 当 `contentValue` 变化时自动渲染
```javascript
contentValueChanged() {
  this.renderContent()  // 重新渲染 Markdown
}
```

## 六、新人学习路径

### 阶段1：理解项目结构（1-2天）

**任务清单：**
1. ✅ 阅读 `config/routes.rb`，理解所有路由
2. ✅ 查看 `app/models/` 下的模型，理解数据关系
3. ✅ 阅读 `app/controllers/` 下的控制器，理解业务逻辑
4. ✅ 查看 `app/views/` 下的视图，理解页面结构

**推荐顺序：**
1. `routes.rb` → 了解有哪些功能
2. `models/user.rb`, `models/room.rb`, `models/message.rb` → 理解数据模型
3. `controllers/rooms_controller.rb`, `controllers/messages_controller.rb` → 理解核心业务
4. `views/rooms/show.html.erb` → 理解主界面

### 阶段2：追踪核心流程（2-3天）

**任务：追踪"用户发送消息"的完整流程**

**步骤：**
1. 找到表单：`app/views/messages/_form.html.erb`
2. 找到路由：`config/routes.rb:22`
3. 找到控制器：`app/controllers/messages_controller.rb:create`
4. 找到任务：`app/jobs/complete_conversation_job.rb:perform`
5. 找到广播：`app/models/message.rb:15` 和 `complete_conversation_job.rb:62`
6. 找到前端订阅：`app/views/rooms/show.html.erb:114`
7. 找到前端处理：`app/javascript/application.js:8` 和 `message_controller.js`

**调试技巧：**
- 在控制器方法中添加 `binding.pry` 或 `puts` 调试
- 在浏览器开发者工具中查看 Network 标签，观察 Turbo Stream 请求
- 在浏览器 Console 中查看 WebSocket 连接

### 阶段3：理解实时通信（2-3天）

**任务：**
1. 理解 `turbo_stream_from` 的作用
2. 理解 `broadcasts_to` 的机制
3. 理解自定义 `message_chunk` Action 的实现
4. 尝试修改消息广播逻辑，观察前端变化

**实践：**
- 在 `rails console` 中手动创建消息，观察前端自动更新
- 修改 `complete_conversation_job.rb` 中的广播逻辑
- 添加新的自定义 Turbo Stream Action

### 阶段4：掌握 Tailwind CSS（1-2天）

**任务：**
1. 查看现有页面的 Tailwind 类名使用
2. 尝试修改样式，观察效果
3. 参考 DaisyUI 文档，使用现成组件

**实践：**
- 修改 `app/views/rooms/show.html.erb` 中的样式类
- 添加新的响应式布局
- 使用 DaisyUI 组件替换自定义样式

### 阶段5：理解 Stimulus（1-2天）

**任务：**
1. 阅读现有的 Stimulus 控制器
2. 理解 `data-controller`, `data-action`, `data-target` 的用法
3. 尝试创建新的简单控制器

**推荐阅读顺序：**
1. `app/javascript/controllers/toast_controller.js` - 最简单的例子
2. `app/javascript/controllers/message_controller.js` - 中等复杂度
3. `app/javascript/controllers/conversation_controller.js` - 理解控制器结构

## 七、关键文件速查表

### 后端核心文件

| 文件 | 作用 | 关键代码 |
|------|------|---------|
| `config/routes.rb` | 路由定义 | 所有URL入口 |
| `app/controllers/messages_controller.rb` | 消息创建 | `create` 方法 |
| `app/jobs/complete_conversation_job.rb` | AI对话生成 | `perform` 方法，流式广播 |
| `app/models/message.rb` | 消息模型 | `broadcasts_to :conversation` |
| `config/cable.yml` | WebSocket配置 | Redis/Async适配器 |

### 前端核心文件

| 文件 | 作用 | 关键代码 |
|------|------|---------|
| `app/javascript/application.js` | JS入口 | Turbo初始化，自定义Action |
| `app/javascript/controllers/message_controller.js` | 消息渲染 | Markdown渲染逻辑 |
| `app/assets/stylesheets/application.tailwind.css` | CSS入口 | Tailwind配置 |
| `app/views/rooms/show.html.erb` | 聊天主页面 | `turbo_stream_from` 订阅 |
| `app/views/messages/_message.html.erb` | 消息组件 | Stimulus控制器连接 |

## 八、调试技巧

### 8.1 后端调试

**在控制器中添加断点：**
```ruby
def create
  binding.pry  # 或 binding.irb
  # ... 代码
end
```

**查看日志：**
```bash
tail -f log/development.log
```

### 8.2 前端调试

**浏览器开发者工具：**
- Network 标签：查看 Turbo Stream 请求
- Console 标签：查看 JavaScript 错误和日志
- Elements 标签：查看 DOM 结构和 Stimulus 数据属性

**添加调试日志：**
```javascript
// app/javascript/controllers/message_controller.js
connect() {
  console.log('Message controller connected', this.element)
}
```

### 8.3 WebSocket 调试

**查看连接状态：**
- 浏览器 Console：`Turbo.StreamSources` 查看订阅的流
- Rails Console：手动触发广播测试

**手动测试广播：**
```ruby
# rails console
conversation = Conversation.first
Turbo::StreamsChannel.broadcast_stream_to(
  conversation,
  content: '<turbo-stream action="append" target="messages"><template><div>Test</div></template></turbo-stream>'
)
```

## 九、常见问题解答

### Q1: 如何找到某个功能的代码？

**方法：**
1. 从路由开始：`config/routes.rb` 找到对应的 controller#action
2. 查看控制器：`app/controllers/xxx_controller.rb`
3. 查看视图：`app/views/xxx/xxx.html.erb`
4. 查看模型：`app/models/xxx.rb`

### Q2: 如何理解前后端数据流？

**核心流程：**
1. 用户操作 → 表单提交/链接点击
2. Turbo 拦截 → 发送 AJAX 请求（不刷新页面）
3. 后端处理 → Controller → Model → 返回 Turbo Stream HTML
4. Turbo 解析 → 自动更新 DOM
5. Stimulus 响应 → 监听数据变化，执行交互逻辑

### Q3: 实时更新是如何工作的？

**机制：**
1. 页面加载时：`turbo_stream_from` 建立 WebSocket 订阅
2. 后端触发：`broadcasts_to` 或 `broadcast_stream_to` 发送更新
3. 前端接收：Turbo 自动解析并更新 DOM
4. Stimulus 响应：监听 DOM 变化，执行交互逻辑

### Q4: Tailwind CSS 类名太多，记不住怎么办？

**策略：**
1. 先看现有代码，复制类似的样式
2. 使用 Tailwind 官方文档搜索需要的样式
3. 使用 DaisyUI 组件，减少自定义样式
4. 逐步记忆常用类名（flex, grid, p-*, m-*, bg-*, text-*）

## 十、下一步学习建议

1. **实践项目**：尝试添加新功能（如消息编辑、删除）
2. **阅读源码**：深入理解 Turbo 和 Stimulus 的工作原理
3. **参考文档**：
   - [Turbo 官方文档](https://turbo.hotwired.dev/)
   - [Stimulus 官方文档](https://stimulus.hotwired.dev/)
   - [Tailwind CSS 文档](https://tailwindcss.com/docs)
   - [DaisyUI 文档](https://daisyui.com/)
4. **扩展功能**：尝试实现文件上传、图片预览等功能

